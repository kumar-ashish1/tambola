{"ast":null,"code":"import{jsxs as _jsxs}from\"react/jsx-runtime\";import{Fragment as _Fragment}from\"react/jsx-runtime\";import{jsx as _jsx}from\"react/jsx-runtime\";import _slicedToArray from\"/Users/ashish/Documents/tambola2/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _classCallCheck from\"/Users/ashish/Documents/tambola2/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/Users/ashish/Documents/tambola2/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import _inherits from\"/Users/ashish/Documents/tambola2/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";import _createSuper from\"/Users/ashish/Documents/tambola2/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";import*as React from\"react\";import{Component}from\"react\";import HostTicket from\"./HostTicket\";import Joyride from\"react-joyride\";var MultipleHostTicket=/*#__PURE__*/function(_Component){_inherits(MultipleHostTicket,_Component);var _super=_createSuper(MultipleHostTicket);function MultipleHostTicket(props){var _this;_classCallCheck(this,MultipleHostTicket);_this=_super.call(this,props);_this.hasWalkthroughShown=void 0;_this.walkThroughSteps=[{target:\".host-ticket\",content:\"This is the player's ticket. They think they have won this award. Your task is to check the 'crossed' numbers on this ticket and tell the players if this is a valid win or a Bogey!\",disableBeacon:true,placement:\"bottom\",disableOverlay:true}];_this.removeTicket=function(idWinCall){var newState=_this.state.ticketFromPlayers;delete newState[idWinCall];_this.setState({ticketFromPlayers:newState});// check if there is no HostTicket then enable the generate new button and emit event for 'Waiting' component\nif(Object.keys(newState).length===0&&newState.constructor===Object){var generateNewButton=document.querySelector(\"button.new-number\");generateNewButton.disabled=false;generateNewButton.classList.remove(\"disabled-button\");_this.props.socket.emit(\"hostCompletedChecking\");}};_this.state={ticketFromPlayers:{},runWalkthrough:false};// hasWalkthrough shown handles this logic: \n// if player tickets become zero then the tutorial is shown and hasWalkthrough shown\n// becomes true and tutorial is never shown. This is the case when in props we receive\n// showWalkthrough as true. If it is false then we just change hasWalkthrough shown to be\n// true and then the walkThrough never playes\n_this.hasWalkthroughShown=!_this.props.showWalkthrough;return _this;}_createClass(MultipleHostTicket,[{key:\"componentDidMount\",value:function componentDidMount(){var _this2=this;this.props.socket.on(\"callWinToHost\",function(callWinObj){// updating values\nvar newTicketsState=_this2.state.ticketFromPlayers;var runWalkthrough=_this2.hasWalkthroughShown?false:true;// JS does not support keys to be objects, so this is easy workaround for the\n// case when same user made 2 different win calls at the same time; The key\n// is a string concatenation of id and wintype\nnewTicketsState[callWinObj.user.id+callWinObj.callWinType]=callWinObj;_this2.setState({ticketFromPlayers:newTicketsState,runWalkthrough:runWalkthrough});// Disable the generate new button\nvar generateNewButton=document.querySelector(\"button.new-number\");generateNewButton.disabled=true;generateNewButton.classList.add(\"disabled-button\");});}},{key:\"render\",value:function render(){var ticketComponents=[];for(var _i=0,_Object$entries=Object.entries(this.state.ticketFromPlayers);_i<_Object$entries.length;_i++){var _Object$entries$_i=_slicedToArray(_Object$entries[_i],2),key=_Object$entries$_i[0],value=_Object$entries$_i[1];var ticket=/*#__PURE__*/_jsx(HostTicket,{socket:this.props.socket,callWinObj:value,removeTicketFromHost:this.removeTicket},key);ticketComponents.push(ticket);}return/*#__PURE__*/_jsxs(_Fragment,{children:[ticketComponents,/*#__PURE__*/_jsx(Joyride,{steps:this.walkThroughSteps,run:this.state.runWalkthrough,continuous:true,disableOverlayClose:true,showProgress:true,showSkipButton:true,spotlightClicks:true,styles:{options:{zIndex:10000,primaryColor:\"#0e141f\",textColor:\"#0e141f\"}}})]});}}]);return MultipleHostTicket;}(Component);export default MultipleHostTicket;","map":{"version":3,"sources":["/Users/ashish/Documents/tambola2/frontend/src/components/MultipleHostTickets.tsx"],"names":["React","Component","HostTicket","Joyride","MultipleHostTicket","props","hasWalkthroughShown","walkThroughSteps","target","content","disableBeacon","placement","disableOverlay","removeTicket","idWinCall","newState","state","ticketFromPlayers","setState","Object","keys","length","constructor","generateNewButton","document","querySelector","disabled","classList","remove","socket","emit","runWalkthrough","showWalkthrough","on","callWinObj","newTicketsState","user","id","callWinType","add","ticketComponents","entries","key","value","ticket","push","options","zIndex","primaryColor","textColor"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport { Component } from \"react\";\nimport { callWin } from \"./Player\";\nimport HostTicket from \"./HostTicket\";\nimport Joyride, { Step } from \"react-joyride\";\nimport Board from \"./Board\";\n\ninterface MultipleHostTicketProps {\n  socket: any;\n  showWalkthrough: boolean;\n}\n\ninterface MultipleHostTicketState {\n  ticketFromPlayers: { [id: string]: callWin };\n  runWalkthrough: boolean;\n}\n\nclass MultipleHostTicket extends Component<\n  MultipleHostTicketProps,\n  MultipleHostTicketState\n> {\n  hasWalkthroughShown: boolean;\n  constructor(props: MultipleHostTicketProps) {\n    super(props);\n    this.state = { ticketFromPlayers: {}, runWalkthrough: false };\n    \n    // hasWalkthrough shown handles this logic: \n    // if player tickets become zero then the tutorial is shown and hasWalkthrough shown\n    // becomes true and tutorial is never shown. This is the case when in props we receive\n    // showWalkthrough as true. If it is false then we just change hasWalkthrough shown to be\n    // true and then the walkThrough never playes\n    this.hasWalkthroughShown = !this.props.showWalkthrough;\n  }\n\n  walkThroughSteps: Step[] = [\n    {\n      target: \".host-ticket\",\n      content:\n        \"This is the player's ticket. They think they have won this award. Your task is to check the 'crossed' numbers on this ticket and tell the players if this is a valid win or a Bogey!\",\n      disableBeacon: true,\n      placement: \"bottom\",\n      disableOverlay: true,\n    },\n  ];\n\n  componentDidMount() {\n    this.props.socket.on(\"callWinToHost\", (callWinObj: callWin) => {\n      // updating values\n      let newTicketsState = this.state.ticketFromPlayers;\n      let runWalkthrough: boolean = this.hasWalkthroughShown ? false : true;\n\n      // JS does not support keys to be objects, so this is easy workaround for the\n      // case when same user made 2 different win calls at the same time; The key\n      // is a string concatenation of id and wintype\n      newTicketsState[callWinObj.user.id + callWinObj.callWinType] = callWinObj;\n      this.setState({\n        ticketFromPlayers: newTicketsState,\n        runWalkthrough: runWalkthrough,\n      });\n      // Disable the generate new button\n      let generateNewButton = document.querySelector(\n        \"button.new-number\"\n      ) as HTMLInputElement;\n      generateNewButton.disabled = true;\n      generateNewButton.classList.add(\"disabled-button\");\n    });\n  }\n\n  removeTicket = (idWinCall: string) => {\n    let newState = this.state.ticketFromPlayers;\n    delete newState[idWinCall];\n    this.setState({ ticketFromPlayers: newState });\n\n    // check if there is no HostTicket then enable the generate new button and emit event for 'Waiting' component\n    if (Object.keys(newState).length === 0 && newState.constructor === Object) {\n      let generateNewButton = document.querySelector(\n        \"button.new-number\"\n      ) as HTMLInputElement;\n      generateNewButton.disabled = false;\n      generateNewButton.classList.remove(\"disabled-button\");\n      this.props.socket.emit(\"hostCompletedChecking\");\n    }\n  };\n\n  render() {\n    let ticketComponents = [];\n    for (const [key, value] of Object.entries(this.state.ticketFromPlayers)) {\n      let ticket = (\n        <HostTicket\n          key={key}\n          socket={this.props.socket}\n          callWinObj={value}\n          removeTicketFromHost={this.removeTicket}\n        />\n      );\n      ticketComponents.push(ticket);\n    }\n    return (\n      <>\n        {ticketComponents}\n        <Joyride\n          steps={this.walkThroughSteps}\n          run={this.state.runWalkthrough}\n          continuous={true}\n          disableOverlayClose={true}\n          showProgress={true}\n          showSkipButton={true}\n          spotlightClicks={true}\n          styles={{\n            options: {\n              zIndex: 10000,\n              primaryColor: \"#0e141f\",\n              textColor: \"#0e141f\",\n            },\n          }}\n        />\n      </>\n    );\n  }\n}\n\nexport default MultipleHostTicket;\n"]},"metadata":{},"sourceType":"module"}